class SanityCheck(Exception):
	pass

def pid_exists(pid):
	"""Check whether pid exists in the current process table."""
	if pid < 0:
		return False
	try:
		kill(pid, 0)
	except ProcessLookupError as e:
		return False
	except OSError as e:
		return e.errno == errno.EPERM
	else:
		return True

def signal_handler(signal, frame):
	try:
		s.close()
	except:
		pass
	remove(pidfile)
	_exit(1)

def sanity_startup_check():
	if core['SSL']['enabled']:
		if not isfile(core['SSL']['key']):
			raise SanityCheck('Certificate error: Missing Key')
		if not isfile(core['SSL']['cert']):
			raise SanityCheck('Certificate error: Missing Cert')

	if isfile(pidfile):
		with open(pidfile) as fh:
			thepid = fh.read()
			if len(thepid) == 0:
				thepid = '-1'
			thepid = int(thepid)
		if pid_exists(thepid):
			exit(1)
		else:
			print('Removed the PID file, dead session!')
			remove(pidfile)

	for storages in core['storages']:
		if storages[0] == '@': continue # It's a flag for soft storage links (for instance postgresql)
		if not isdir(core['storages'][storages]):
			print(' ! Warning - Missing storage: ' + core['storages'][storages])
			## TODO: Create these missing folders,
			##       but do it in a clean non-introusive way
			##       (for instance, having default storage to /var would cause issues)

def getDomainInfo(domain):
	if '@' in domain:
		domain = domain.split('@',1)[1]
	
	if domain.count('.') > 2:
		host, domain = domain.split('.',1)
	else:
		host = None

	return host, domain

def splitMail(to):
	return to.split('@', 1)

def save_mail(mail_file, message, account):
	with open(mail_file, 'w') as fh:
		fh.write(message)
	if isfile(mail_file):
		uid = pwd.getpwnam(account).pw_uid
		gid = grp.getgrnam(account).gr_gid
		chown(mail_file, uid, gid)

def getDbDomains():
	conn = psycopg2.connect('dbname='+core['postgres']['db'] +' user='+core['postgres']['dbuser'] +' password='+core['postgres']['dbpass'])
	cur = conn.cursor(cursor_factory=psycopg2.extras.DictCursor)
	cur.execute("SELECT domain FROM smtp;")
	results = []
	for row in cur.fetchall():
		if row['domain'] in results: continue
		results.append(row['domain'])
	cur.close()
	conn.close()
	return results

def local_mail(_from, _to, message):
	mailbox, domain = splitMail(_to)

	if _to in core['storages']:
		print(' | Delivering to local storage: ~/'+_to, '(soft-link)')
		path = core['storages'][_to] + '/'
		mail_file = abspath(path + '/new/') + '/' + _from + '-' + str(time()) + '.mail'

		# TODO: remove ../ form _from
		save_mail(mail_file, message, mailbox)

	elif '@POSTGRESQL' in core['storages'] and core['storages']['@POSTGRESQL']:
		conn = psycopg2.connect('dbname='+core['postgres']['db'] +' user='+core['postgres']['dbuser'] +' password='+core['postgres']['dbpass'])
		cur = conn.cursor(cursor_factory=psycopg2.extras.DictCursor)

		# mailbox, domain,  account_backend
		# anton    gh.com   PAM
		# anton    @SOCIAL  ALIAS
		# facebook gh.com   @SOCIAL
		# twitter  gh       @SOCIAL
		cur.execute("SELECT * FROM smtp WHERE mailbox='"+mailbox+"' AND domain='"+domain+"';")
		for row in cur.fetchall():
			if row['account_backend'] == 'PAM':
				print(' | Delivering to local storage: ~/'+_to, '(postgresql)')
				mail_file = abspath(expanduser('~'+row['mailbox']) + '/Maildir/new/' + _from + '-' + str(time()) + '.mail')
				save_mail(mail_file, message, row['mailbox'])

			elif row['account_backend'][0] == '@':
				# TODO: Don't forget to check backend_account against subcursor results!
				#       :)
				print(' | Delivering to shared mailbox:', row['mailbox'], '(postgresql)')
				print(' |- Members:')
				subcur = conn.cursor(cursor_factory=psycopg2.extras.DictCursor)
				subcur.execute("SELECT * FROM smtp WHERE domain='"+row['account_backend']+"';")
				for subrow in subcur.fetchall():
					print(' |    ', subrow['mailbox']+'@'+row['domain'])
					mail_file = abspath(expanduser('~'+subrow['mailbox']) + '/Maildir/new/' + _from + '-' + str(time()) + '.mail')
					save_mail(mail_file, message, subrow['mailbox'])
				subcur.close()
		cur.close()
		conn.close()

	else:
		print(' | Delivering to local storage: ~/'+_to, '(default-link)')
		path = core['storages']['default'] + '/'
		mail_file = abspath(path + '/new/') + '/' + _from + '-' + str(time()) + '.mail'


		# TODO: remove ../ form _from
		save_mail(mail_file, message, mailbox)

	return True

def external_mail(_from, to, message):
	import dns.resolver
	for x in dns.resolver.query(getDomainInfo(to)[1], 'MX'):
		try:
			print(' | Trying to deliver externally via MX lookup:', x.exchange.to_text())
			server = smtplib.SMTP(x.exchange.to_text().rstrip('\\.,\'"\r\n '), 587, timeout=5)
			server.ehlo()
			server.starttls()
		except:
			try:
				server = smtplib.SMTP(x.exchange.to_text().rstrip('\\.,\'"\r\n '), 25, timeout=5)
				server.ehlo()
				server.starttls()
			except:
				if core['external']['enforce_tls']:
					print(' ! The relay-server doesn\'t support TLS/SSL!')
					try: server.quit()
					except: pass
					continue # Try the next one
				else:
					print(' ! Could not initated TLS, falling back to PLAIN')
					try: server.quit()
					except: pass
					try:
						server = smtplib.SMTP(x, 25, timeout=5)
						server.ehlo()
					except:
						try: server.quit()
						except: pass
						continue

		try:
			server.sendmail(_from, to, message)
		except smtplib.SMTPRecipientsRefused:
			print(' ! Could not relay the mail, Recipient Refused!')
			server.quit()
			return False

		except Exception as e:
			if type(e) == tuple and len(e) >= 3:
				print( ' !- ' + str(e[0]) + ' ' + str(e[1]))
			server.quit()
			return False

		print(' | Delivery done!')
		server.quit()
		return True

	print(' ! No more external servers to try for the domain:', getDomainInfo(to)[1])
	return False

def relay(_from, to, message):
	server = smtplib.SMTP(core['relay'][0], core['relay'][1])
	server.ehlo()
	if core['relay'][2]:
		try:
			server.starttls()
		except:
			print( ' ! The relay-server doesn\'t support TLS/SSL!')
			server.quit()
			return False
	if len(core['relay']) >= 5:
		try:
			server.login(core['relay'][3], core['relay'][4])
		except:
			print( ' ! Invalid credentials towards relay server')
			server.quit()
			return False
	try:
		server.sendmail(_from, to, message)
	except smtplib.SMTPRecipientsRefused:
		print( ' ! Could not relay the mail, Recipient Refused!')
		server.quit()
		return False
	except Exception as e:
		if type(e) == tuple and len(e) >= 3:
			print( ' !- ' + str(e[0]) + ' ' + str(e[1]))
		server.quit()
		return False

	server.quit()
	return True